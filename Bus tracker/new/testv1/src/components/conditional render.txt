You've got it\! Let's break down the changes made to your React code and why they effectively solve the issue of components stacking.

-----

## The Core Problem: Independent State

The original problem was that each `Buttons` component had its own **local state** (`ren`). When you clicked a button, only that specific button knew whether it should render its associated content. Clicking a *different* button didn't tell the *first* button to close, leading to multiple content areas being displayed simultaneously.

-----

## The Solution: State Hoisting

The fundamental change we implemented is called **state hoisting**. This means moving the state that controls the visibility of the content from the individual `Buttons` components up to their common parent, the `BottomBar` component.

Here's a detailed look at the changes:

-----

## `BottomBar.jsx` Changes

This is where the most significant changes occurred:

1.  **Introducing `useState` for `activeButton`:**

    ```jsx
    import { useState } from 'react'; // Added this import
    // ...
    export default function BottomBar() {
        const [activeButton, setActiveButton] = useState(null);
        // ...
    }
    ```

      * **What it does:** We added a new state variable, `activeButton`, initialized to `null`. This variable will now keep track of *which* button's content should currently be displayed. If it's `null`, no content is active. If it holds a button's `name` (e.g., "Schedule"), then that button's content should be shown.
      * **Why it's important:** By having a single source of truth for the active state in the parent component, we can ensure that only one content area is open at a time.

2.  **`handleButtonClick` Function:**

    ```jsx
    const handleButtonClick = (buttonName) => {
        setActiveButton(prevActiveButton =>
            prevActiveButton === buttonName ? null : buttonName
        );
    };
    ```

      * **What it does:** This new function is responsible for updating the `activeButton` state.
          * If the `buttonName` passed to it (meaning the button that was just clicked) is *already* the `prevActiveButton`, it means the user clicked the *same* button again. In this case, we set `activeButton` to `null` to close the currently open content.
          * If the `buttonName` is *different* from `prevActiveButton`, it means a *new* button was clicked. We then set `activeButton` to the `buttonName` of the newly clicked button, effectively opening its content and implicitly closing any previously open content.
      * **Why it's important:** This logic ensures the "toggle" behavior for a single button and the "replace" behavior when switching between different buttons.

3.  **Passing Props to `Buttons`:**

    ```jsx
    {buttonArray.map(type => (
        <Buttons
            key={type.name}
            prop={type}
            isActive={activeButton === type.name} // NEW
            onClick={() => handleButtonClick(type.name)} // NEW
        />
    ))}
    ```

      * **What it does:** We're now passing two new props to each `Buttons` component:
          * `isActive`: A boolean (`true` or `false`) that tells the `Buttons` component if *it* is currently the active button. This is useful for styling (e.g., making the active button appear highlighted).
          * `onClick`: Instead of each button having its own internal click handler, we pass down the `handleButtonClick` function. When a `Buttons` component is clicked, it will now call this `onClick` prop, passing its own `name` back up to the `BottomBar`.
      * **Why it's important:** This transforms `Buttons` into a **controlled component**. Its behavior (whether it's "active") is now entirely determined by props from its parent, rather than its own internal state.

4.  **Centralized Conditional Rendering:**

    ```jsx
    {activeButton && (
        <div className={`function-box`}>
            {/* Find the function associated with the active button and render it */}
            {buttonArray.find(button => button.name === activeButton)?.func()}
        </div>
    )}
    ```

      * **What it does:** We've moved the rendering of the `function-box` and its dynamic content *out* of the `Buttons` component and into `BottomBar`.
          * `activeButton && (...)`: This renders the `div` only if `activeButton` has a value (i.e., a button is selected). If `activeButton` is `null`, nothing is rendered.
          * `buttonArray.find(button => button.name === activeButton)?.func()`: This is the magic part. It searches the `buttonArray` to find the object whose `name` matches the `activeButton` state. Once found, it accesses its `func` property (which holds `displaySchedule`, `displayRoutes`, etc.) and *calls* that function. React then renders the JSX returned by that function.
      * **Why it's important:** This is the core of the solution. Since only *one* `activeButton` can exist at a time, only *one* associated `func` will be called and rendered here. When `activeButton` changes (because a new button was clicked), React re-renders `BottomBar`, unmounting the old `function-box` and mounting the new one. This ensures that content is replaced, not stacked.

-----

## `Buttons.jsx` Changes

The `Buttons` component became simpler:

1.  **Removed `useState`:**

    ```jsx
    // import { useState } from "react" // Removed this line
    // const [ren, setRen] = useState(false) // Removed this line
    ```

      * **What it does:** The `ren` state is no longer needed in `Buttons` because its active/inactive status is now managed by the parent.
      * **Why it's important:** This makes `Buttons` a "dumb" or "presentational" component. It simply receives props and renders UI based on them, delegating state management to its parent.

2.  **Using `isActive` and `onClick` Props:**

    ```jsx
    export default function Buttons({ prop, isActive, onClick }) { // Added isActive, onClick
        return (
            <button
                // ...
                className={`bottom-bar-buttons ${isActive ? 'active' : ''}`} // Using isActive for styling
                onClick={onClick} // Using the onClick prop directly
            >
            // ...
            {/* Removed the {ren && ...} block */}
            </button>
        )
    }
    ```

      * **What it does:**
          * It now accepts `isActive` and `onClick` as props.
          * The `className` can now conditionally add an `active` class based on the `isActive` prop, allowing you to style the currently selected button differently.
          * The `onClick` handler directly calls the `onClick` prop received from the parent.
          * The conditional rendering block (`{ren && (...)`) that was responsible for showing the content *inside* the button was removed, as that responsibility moved to `BottomBar`.
      * **Why it's important:** This reinforces that the `Buttons` component is now fully controlled by its parent. It doesn't decide what to render; it just tells the parent it was clicked and receives its active state from the parent.

-----

## `displaySchedule.jsx` (and other display functions) Changes

1.  **Removed `setRen`, `ren` parameters:**
    ```jsx
    export default function displaySchedule() { // Removed setRen, ren parameters
        return (<div>hi from Schedule</div>);
    }
    ```
      * **What it does:** Since the `displaySchedule` (and other `displayX` functions) are now directly called by `BottomBar` and are no longer responsible for managing their own visibility via `setRen` or `ren`, these parameters are no longer needed.
      * **Why it's important:** Simplifies these display components, as they only need to return the JSX they are responsible for.

-----

## In Summary:

By **lifting the state** of which button is active to the `BottomBar` component, we created a single point of control. When a button is clicked, `BottomBar` updates its `activeButton` state. This then triggers a re-render where `BottomBar` intelligently decides to either unmount the previously displayed content and mount new content, or simply unmount the current content if the same button was clicked again. This ensures that only one content panel is ever visible at a time.